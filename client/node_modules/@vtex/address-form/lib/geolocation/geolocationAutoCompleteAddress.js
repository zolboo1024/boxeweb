'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = geolocationAutoCompleteAddress;

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _reduce = require('lodash/reduce');

var _reduce2 = _interopRequireDefault(_reduce);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _countryISOMap = require('../countryISOMap');

var _countryISOMap2 = _interopRequireDefault(_countryISOMap);

var _flow = require('lodash/flow');

var _flow2 = _interopRequireDefault(_flow);

var _address = require('../transforms/address');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function geolocationAutoCompleteAddress(baseAddress, googleAddress, rules) {
  var geolocationRules = rules.geolocation;
  var fallbackCountry = rules.country;

  var address = (0, _flow2.default)([setAddressFields, runGeolocationFieldHandlers, setGeoCoordinates, setCountry, setAddressQuery, function (address) {
    return (0, _address.addNewField)(address, 'geolocationAutoCompleted', true);
  }, function (address) {
    return _extends({}, address, {
      addressId: baseAddress.addressId,
      addressType: baseAddress.addressType,
      receiverName: baseAddress.receiverName
    });
  }, function (address) {
    return (0, _address.addFocusToNextInvalidField)(address, rules);
  }])();

  // unnecessary for 3.6.0+, but necessary for backward compatibility
  // for lib consumers that don't pass `useGeolocation` to the `<AddressRules/>`
  if (!rules._usingGeolocationRules) {
    address = setNumberNotApplicable(address);
  }

  // The functions below use googleAddress and geolocationRules
  // from the closure created.

  function setAddressFields() {
    var indexedRules = revertRuleIndex(geolocationRules);

    return (0, _reduce2.default)(googleAddress.address_components, function (address, component) {
      var checkoutFieldName = getCheckoutFieldName(component.types, indexedRules);

      if (checkoutFieldName) {
        address = setAddressFieldValue(address, checkoutFieldName, geolocationRules, component);
      }
      return address;
    }, {});
  }

  function setGeoCoordinates(address) {
    var location = googleAddress.geometry.location;

    address.geoCoordinates = {
      visited: true,
      value: [(0, _isFunction2.default)(location.lng) ? location.lng() : location.lng, (0, _isFunction2.default)(location.lat) ? location.lat() : location.lat]
    };

    return address;
  }

  // Run custom function handlers to fill some fields
  function runGeolocationFieldHandlers(address) {
    (0, _map2.default)(geolocationRules, function (rule, propName) {
      if (rule.handler) {
        address = rule.handler(address, googleAddress);
      }
    });

    (0, _map2.default)(geolocationRules, function (rule, propName) {
      if (rule.handler) {
        address = rule.handler(address, googleAddress);
      }
    });

    return address;
  }

  function setCountry(address) {
    var country = getCountry(googleAddress);
    address.country = { value: country || fallbackCountry };
    return address;
  }

  function setAddressQuery(address) {
    address.addressQuery = { value: googleAddress.formatted_address };

    return address;
  }

  function setNumberNotApplicable(address) {
    var geolocationNumberCondition = geolocationRules && geolocationRules.number && geolocationRules.number.notApplicable;
    if (geolocationNumberCondition) {
      return _extends({}, address, {
        number: _extends({}, address.number, {
          notApplicable: true
        })
      });
    }
    return address;
  }

  return address;
}

/** This function creates a map like this:
 * {
 *   "postal_code": "postalCode",
 *   "street_number": "number",
 *   "route": "street",
 *   "neighborhood": "neighborhood",
 *   "sublocality_level_1": "neighborhood",
 *   "sublocality_level_2": "neighborhood",
 *   "sublocality_level_3": "neighborhood",
 *   "sublocality_level_4": "neighborhood",
 *   "sublocality_level_5": "neighborhood",
 *   "administrative_area_level_1": "state",
 *   "administrative_area_level_2": "city",
 *   "locality": "city"
 * }
 * So it's easy to find which Google address type matches ours
 **/
function revertRuleIndex(geolocationRules) {
  return (0, _reduce2.default)(geolocationRules, function (acc, value, propName) {
    for (var i = 0; i < value.types.length; i++) {
      var type = value.types[i];
      acc[type] = propName;
    }
    return acc;
  }, {});
}

// Return the matched checkout field name
function getCheckoutFieldName(types, indexedRules) {
  var mappedType = (0, _find2.default)(types, function (type) {
    return indexedRules[type];
  });
  return mappedType ? indexedRules[mappedType] : null;
}

function setAddressFieldValue(address, fieldName, geolocationRules, addressComponent) {
  var geolocationField = geolocationRules[fieldName];
  address[fieldName] = { value: addressComponent[geolocationField.valueIn] };
  return address;
}

function getCountry(googleAddress) {
  var countryComponent = (0, _find2.default)(googleAddress.address_components, function (component) {
    return component.types.indexOf('country') !== -1;
  });

  return countryComponent ? (0, _countryISOMap2.default)(countryComponent.short_name) : null;
}
module.exports = exports['default'];