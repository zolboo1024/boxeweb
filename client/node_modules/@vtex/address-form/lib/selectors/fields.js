'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getField = getField;
exports.hasOptions = hasOptions;
exports.normalizeOptions = normalizeOptions;
exports.getListOfOptions = getListOfOptions;
exports.getDependentFields = getDependentFields;
exports.filterPostalCodeFields = filterPostalCodeFields;
exports.isDefiningPostalCodeField = isDefiningPostalCodeField;
exports.filterAutoCompletedFields = filterAutoCompletedFields;

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _filter = require('lodash/filter');

var _filter2 = _interopRequireDefault(_filter);

var _reduce = require('lodash/reduce');

var _reduce2 = _interopRequireDefault(_reduce);

var _last = require('lodash/last');

var _last2 = _interopRequireDefault(_last);

var _forEach = require('lodash/forEach');

var _forEach2 = _interopRequireDefault(_forEach);

var _constants = require('../constants');

var _hasOption = require('./hasOption');

var _hasOption2 = _interopRequireDefault(_hasOption);

var _cleanStr = require('./cleanStr');

var _cleanStr2 = _interopRequireDefault(_cleanStr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getField(fieldName, rules) {
  return (0, _find2.default)(rules.fields, function (_ref) {
    var name = _ref.name;
    return name === fieldName;
  });
}

function hasOptions(field, address) {
  var hasValueOptions = address && address[field.name] && address[field.name].valueOptions;

  return !!(field.options || field.optionsPairs || field.optionsMap || hasValueOptions);
}

function getFieldValue(field) {
  return (typeof field === 'undefined' ? 'undefined' : _typeof(field)) === 'object' ? field.value : field;
}

function normalizeOptions(options) {
  return (0, _reduce2.default)(options, function (acc, option, key) {
    acc[(0, _cleanStr2.default)(key)] = option;
    return acc;
  }, {});
}

function fixOptions(options, fieldOptions) {
  return (0, _reduce2.default)(options, function (acc, option) {
    var cleanOption = (0, _hasOption2.default)(option, fieldOptions);
    return cleanOption ? acc.concat(cleanOption) : acc;
  }, []);
}

function getListOfOptions(field, address, rules) {
  // Has options provided by Postal Code
  var postalCodeOptions = address && address[field.name] && address[field.name].valueOptions;

  if (postalCodeOptions) {
    if (field.options && !field.basedOn) {
      return (0, _map2.default)(fixOptions(postalCodeOptions, field.options), toValueAndLabel);
    }

    if (field.optionsMap && field.basedOn && field.level === 2) {
      return (0, _map2.default)(fixOptions(postalCodeOptions, getSecondLevelOptions(field, address)), toValueAndLabel);
    }

    if (field.optionsMap && field.basedOn && field.level === 3) {
      return (0, _map2.default)(fixOptions(postalCodeOptions, getThirdLevelOptions(field, address, rules)), toValueAndLabel);
    }

    return (0, _map2.default)(address[field.name].valueOptions, toValueAndLabel);
  }

  if (field.options) {
    return (0, _map2.default)(field.options, toValueAndLabel);
  }

  if (field.optionsPairs) {
    return field.optionsPairs;
  }

  if (field.optionsMap && field.basedOn && field.level === 2) {
    return (0, _map2.default)(getSecondLevelOptions(field, address), toValueAndLabel);
  }

  if (field.optionsMap && field.basedOn && field.level === 3) {
    return (0, _map2.default)(getThirdLevelOptions(field, address, rules), toValueAndLabel);
  }

  if (process.env.NODE_ENV !== 'production') {
    throw new Error('Invalid rule set');
  } else {
    return [];
  }
}

function getSecondLevelOptions(field, address) {
  var basedOn = getFieldValue(address[field.basedOn]);
  var cleanBasedOn = (0, _cleanStr2.default)(basedOn);
  var normalizedOptionsMap = normalizeOptions(field.optionsMap);
  if (cleanBasedOn && normalizedOptionsMap[cleanBasedOn]) {
    return normalizedOptionsMap[cleanBasedOn];
  }

  return [];
}

function getThirdLevelOptions(field, address, rules) {
  var secondLevelField = getField(field.basedOn, rules);
  var firstLevelField = getField(secondLevelField.basedOn, rules);

  var secondLevelValue = getFieldValue(address[secondLevelField.name]);
  var firstLevelValue = getFieldValue(address[firstLevelField.name]);

  var normalizedOptionsMap = normalizeOptions(field.optionsMap);
  var cleanFirstLevelValue = (0, _cleanStr2.default)(firstLevelValue);

  if (cleanFirstLevelValue && secondLevelValue && normalizedOptionsMap[cleanFirstLevelValue] && normalizedOptionsMap[cleanFirstLevelValue][secondLevelValue]) {
    return normalizedOptionsMap[cleanFirstLevelValue][secondLevelValue];
  }

  return [];
}

function toValueAndLabel(option) {
  return { value: option, label: option };
}

function getDependentFields(fieldName, rules) {
  var dependentFields = [];

  if (fieldAffectsPostalCode(fieldName, rules)) {
    dependentFields = [].concat(dependentFields, ['postalCode']);
  }

  var dependentField = getFieldBasedOn(fieldName, rules);
  if (dependentField) {
    dependentFields = [].concat(dependentFields, [dependentField]);

    var secondLevelField = getFieldBasedOn(dependentField, rules);
    if (secondLevelField) {
      dependentFields = [].concat(dependentFields, [secondLevelField]);
    }
  }

  return dependentFields;
}

function getFieldBasedOn(fieldName, rules) {
  var field = (0, _find2.default)(rules.fields, function (_ref2) {
    var basedOn = _ref2.basedOn;
    return basedOn === fieldName;
  });
  return field ? field.name : null;
}

function filterPostalCodeFields(rules) {
  switch (rules.postalCodeFrom) {
    case _constants.THREE_LEVELS:
      return (0, _filter2.default)(rules.fields, function (_ref3) {
        var name = _ref3.name;
        return rules.postalCodeLevels.indexOf(name) === -1;
      });
    case _constants.TWO_LEVELS:
      return (0, _filter2.default)(rules.fields, function (_ref4) {
        var name = _ref4.name;
        return rules.postalCodeLevels.indexOf(name) === -1;
      });
    case _constants.ONE_LEVEL:
      return (0, _filter2.default)(rules.fields, function (_ref5) {
        var name = _ref5.name;
        return rules.postalCodeLevels[0] !== name;
      });
    default:
    case _constants.POSTAL_CODE:
      return (0, _filter2.default)(rules.fields, function (_ref6) {
        var name = _ref6.name;
        return name !== 'postalCode';
      });
  }
}

function fieldAffectsPostalCode(fieldName, rules) {
  return rules.postalCodeLevels && rules.postalCodeLevels.indexOf(fieldName) !== -1;
}

function isDefiningPostalCodeField(fieldName, rules) {
  var lastLevelField = (0, _last2.default)(rules.postalCodeLevels);

  return fieldName === lastLevelField;
}

function filterAutoCompletedFields(rules, address) {
  return (0, _reduce2.default)(rules.fields, function (fields, field) {
    var addressField = address[field.name];

    if (addressField && !addressField.valueOptions && (addressField.postalCodeAutoCompleted || addressField.geolocationAutoCompleted)) {
      return fields;
    }

    return fields.concat(field);
  }, []);
}